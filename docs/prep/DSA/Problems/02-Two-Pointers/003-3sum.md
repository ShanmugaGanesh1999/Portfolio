# 3Sum

| Difficulty | LeetCode # | Pattern |
|------------|------------|---------|
| Medium | 15 | Sort + Two Pointers |

---

## Phase 1: Clarification & Edge Cases

### Interpretation
Find all unique triplets in array that sum to zero.

### Constraints & Clarifying Questions
1. **Can we reuse elements?** No, each triplet uses different indices.
2. **What about duplicates?** Result must not contain duplicate triplets.
3. **Array length?** 3 to 3000 elements.
4. **Value range?** -10^5 to 10^5.
5. **Order of triplets?** Any order is fine.

### Edge Cases
1. **All zeros:** `nums = [0, 0, 0, 0]` → `[[0, 0, 0]]`
2. **No solution:** `nums = [1, 2, 3]` → `[]`
3. **All positive or all negative:** `nums = [1, 1, 1]` → `[]`

---

## Phase 2: High-Level Approach

### Option 1: Naïve (Three Nested Loops)
Check all triplets.
- **Time:** O(N³)
- **Space:** O(1)

### Option 2: Optimal (Sort + Two Pointers)
Sort array. Fix first element, use two pointers to find pairs that sum to its negation. Skip duplicates at each level.

**Core Insight:** Sorting enables two-pointer technique for inner pair and efficient duplicate skipping.

### Why Optimal?
Reduces from O(N³) to O(N²) by using sorted two-pointer search for each fixed first element.

---

## Phase 3: Python Code

```python
def solve(numbers: list[int]) -> list[list[int]]:
    """
    Find all unique triplets that sum to zero.
    
    Args:
        numbers: Array of integers
    
    Returns:
        List of unique triplets [a, b, c] where a + b + c = 0
    """
    numbers.sort()  # O(N log N)
    triplets = []
    n = len(numbers)
    
    for i in range(n - 2):  # O(N)
        # Skip duplicates for first element
        if i > 0 and numbers[i] == numbers[i - 1]:
            continue
        
        # Early termination: if smallest is positive, no solution possible
        if numbers[i] > 0:
            break
        
        # Two pointers for remaining two elements
        target = -numbers[i]
        left = i + 1
        right = n - 1
        
        while left < right:  # O(N) per i
            current_sum = numbers[left] + numbers[right]
            
            if current_sum == target:
                triplets.append([numbers[i], numbers[left], numbers[right]])
                
                # Skip duplicates for second element
                while left < right and numbers[left] == numbers[left + 1]:
                    left += 1
                # Skip duplicates for third element
                while left < right and numbers[right] == numbers[right - 1]:
                    right -= 1
                
                left += 1
                right -= 1
            
            elif current_sum < target:
                left += 1
            
            else:
                right -= 1
    
    return triplets
```

---

## Phase 4: Dry Run

**Input:** `numbers = [-1, 0, 1, 2, -1, -4]`

**After sorting:** `[-4, -1, -1, 0, 1, 2]`

| i | numbers[i] | target | left | right | Sum | Action | Result |
|---|------------|--------|------|-------|-----|--------|--------|
| 0 | -4 | 4 | 1 | 5 | -1+2=1 | 1<4, left++ | — |
| — | -4 | 4 | 2 | 5 | -1+2=1 | 1<4, left++ | — |
| — | -4 | 4 | 3 | 5 | 0+2=2 | 2<4, left++ | — |
| — | -4 | 4 | 4 | 5 | 1+2=3 | 3<4, left++ | — |
| — | -4 | 4 | 5 | 5 | left≥right | Move to i=1 | — |
| 1 | -1 | 1 | 2 | 5 | -1+2=1 | Found! | [[-1,-1,2]] |
| — | -1 | 1 | 3 | 4 | 0+1=1 | Found! | [[-1,-1,2],[-1,0,1]] |
| — | -1 | 1 | 4 | 3 | left≥right | Move to i=2 | — |
| 2 | -1 | — | — | — | Skip (dup) | Move to i=3 | — |
| 3 | 0 | 0 | 4 | 5 | 1+2=3 | 3>0, right-- | — |
| — | 0 | 0 | 4 | 4 | left≥right | Move to i=4 | — |
| 4 | 1 | — | — | — | 1>0, break | End | — |

**Result:** `[[-1, -1, 2], [-1, 0, 1]]`

---

## Phase 5: Complexity Analysis

### Time Complexity: O(N²)
- Sorting: O(N log N)
- Outer loop: O(N) iterations
- Inner two-pointer: O(N) per outer iteration
- Total: O(N log N + N²) = O(N²)

### Space Complexity: O(1) or O(N)
- O(1) auxiliary space (pointers only)
- O(N) if counting the output list
- O(log N) to O(N) for sorting space depending on implementation

---

## Phase 6: Follow-Up Questions

1. **"What if we need 4Sum?"**
   → Add another outer loop fixing the first two elements; use two pointers for remaining pair. O(N³) time.

2. **"What if we need triplets summing to any target, not just zero?"**
   → Change `target = -numbers[i]` to `target = target_sum - numbers[i]`.

3. **"How would you handle very large arrays that don't fit in memory?"**
   → External sort, then process chunks; requires careful handling of triplets spanning chunk boundaries.
