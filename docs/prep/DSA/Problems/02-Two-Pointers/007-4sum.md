# 4Sum

| Difficulty | LeetCode # | Pattern |
|------------|------------|---------|
| Medium | 18 | Sort + Two Pointers (Nested) |

---

## Phase 1: Clarification & Edge Cases

### Interpretation
Find all unique quadruplets in array that sum to target.

### Constraints & Clarifying Questions
1. **Can we reuse indices?** No, all four indices must be distinct.
2. **Duplicates in result?** Not allowed.
3. **Array length?** 1 to 200 elements.
4. **Value range?** -10^9 to 10^9 (watch for overflow!).
5. **Target range?** -10^9 to 10^9.

### Edge Cases
1. **Less than 4 elements:** `nums = [1,2,3]` → []
2. **All same value:** `nums = [0,0,0,0], target = 0` → [[0,0,0,0]]
3. **Overflow potential:** Large values requiring long arithmetic

---

## Phase 2: High-Level Approach

### Option 1: Naïve (Four Nested Loops)
Check all quadruplets.
- **Time:** O(N⁴)
- **Space:** O(1)

### Option 2: Optimal (Sort + Two Nested Loops + Two Pointers)
Sort array. Fix first two elements with nested loops, use two pointers for remaining pair.

**Core Insight:** Extends 3Sum pattern—each outer loop reduces problem dimension until two-pointer search works.

### Why Optimal?
Reduces from O(N⁴) to O(N³) by using two-pointer technique for innermost pair.

---

## Phase 3: Python Code

```python
def solve(numbers: list[int], target: int) -> list[list[int]]:
    """
    Find all unique quadruplets summing to target.
    
    Args:
        numbers: Array of integers
        target: Target sum
    
    Returns:
        List of unique quadruplets [a, b, c, d] where a + b + c + d = target
    """
    numbers.sort()  # O(N log N)
    n = len(numbers)
    quadruplets = []
    
    for i in range(n - 3):  # O(N)
        # Skip duplicates for first element
        if i > 0 and numbers[i] == numbers[i - 1]:
            continue
        
        # Pruning: if minimum possible sum > target, no solution
        if numbers[i] + numbers[i+1] + numbers[i+2] + numbers[i+3] > target:
            break
        # Pruning: if maximum possible sum < target, skip this i
        if numbers[i] + numbers[n-1] + numbers[n-2] + numbers[n-3] < target:
            continue
        
        for j in range(i + 1, n - 2):  # O(N)
            # Skip duplicates for second element
            if j > i + 1 and numbers[j] == numbers[j - 1]:
                continue
            
            # Similar pruning for inner loop
            if numbers[i] + numbers[j] + numbers[j+1] + numbers[j+2] > target:
                break
            if numbers[i] + numbers[j] + numbers[n-1] + numbers[n-2] < target:
                continue
            
            # Two pointers for remaining pair
            left = j + 1
            right = n - 1
            remaining_target = target - numbers[i] - numbers[j]
            
            while left < right:  # O(N)
                pair_sum = numbers[left] + numbers[right]
                
                if pair_sum == remaining_target:
                    quadruplets.append([numbers[i], numbers[j], 
                                       numbers[left], numbers[right]])
                    
                    # Skip duplicates
                    while left < right and numbers[left] == numbers[left + 1]:
                        left += 1
                    while left < right and numbers[right] == numbers[right - 1]:
                        right -= 1
                    
                    left += 1
                    right -= 1
                
                elif pair_sum < remaining_target:
                    left += 1
                else:
                    right -= 1
    
    return quadruplets
```

---

## Phase 4: Dry Run

**Input:** `numbers = [1, 0, -1, 0, -2, 2], target = 0`

**After sorting:** `[-2, -1, 0, 0, 1, 2]`

| i | j | left | right | Sum | Action | Result |
|---|---|------|-------|-----|--------|--------|
| 0 (-2) | 1 (-1) | 2 | 5 | -2-1+0+2=-1 | -1<0, L++ | — |
| 0 | 1 | 3 | 5 | -2-1+0+2=-1 | -1<0, L++ | — |
| 0 | 1 | 4 | 5 | -2-1+1+2=0 | Found! | [[-2,-1,1,2]] |
| 0 | 2 (0) | 3 | 5 | -2+0+0+2=0 | Found! | [..., [-2,0,0,2]] |
| 0 | 3 (0) | skip dup | — | — | — | — |
| 0 | 4 (1) | 5 | 5 | — | L≥R | — |
| 1 (-1) | 2 (0) | 3 | 5 | -1+0+0+2=1 | 1>0, R-- | — |
| 1 | 2 | 3 | 4 | -1+0+0+1=0 | Found! | [..., [-1,0,0,1]] |
| ... | ... | ... | ... | ... | ... | ... |

**Result:** `[[-2,-1,1,2], [-2,0,0,2], [-1,0,0,1]]`

---

## Phase 5: Complexity Analysis

### Time Complexity: O(N³)
- Sorting: O(N log N)
- Two outer loops: O(N²)
- Inner two-pointer: O(N) per outer iteration
- Total: O(N³)

### Space Complexity: O(1) or O(N)
- O(1) auxiliary for pointers
- O(log N) to O(N) for sorting
- Output size varies based on valid quadruplets

---

## Phase 6: Follow-Up Questions

1. **"How to generalize to kSum?"**
   → Recursive approach: for k > 2, fix one element and recursively solve (k-1)Sum. Base case uses two-pointer.

2. **"How to handle integer overflow with large values?"**
   → Use Python (handles big integers) or cast to long in other languages before summing.

3. **"What if we need count of quadruplets instead of listing them?"**
   → Still O(N³), but can avoid storing results. For faster counting with specific constraints, might use hash-based approaches.
